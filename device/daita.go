//go:build daita
// +build daita

package device

import (
	"encoding/binary"
	"sync"
	"time"
	"unsafe"
)

// #include <stdio.h>
// #include <stdlib.h>
// #include "../maybenot/crates/maybenot-ffi/maybenot.h"
// #cgo LDFLAGS: -L${SRCDIR}/../ -lmaybenot -lm
import "C"

type MaybenotDaita struct {
	events        chan Event
	actions       chan Action
	maybenot      *C.MaybenotFramework
	newActionsBuf []C.MaybenotAction
	paddingQueue  map[uint64]*time.Timer // Map from machine to queued padding packets
	logger        *Logger
	stopping      sync.WaitGroup // waitgroup for handleEvents and HandleDaitaActions
}

type Event struct {
	// The machine that generated the action that generated this event, if any.
	Machine uint64

	Peer      NoisePublicKey
	EventType EventType
	XmitBytes uint16
}

const (
	ERROR_GENERAL_FAILURE      = -1
	ERROR_INTERMITTENT_FAILURE = -2
)

type Action struct {
	ActionType C.MaybenotAction_Tag

	// The maybenot machine that generated the action.
	// Should be propagated back by events generated by this action.
	Machine uint64

	// -- The fields below may or may not be used depending on ActionType --

	// Used for ActionTypes: Cancel
	Timer C.MaybenotTimer

	// The time at which the action should be performed
	// Used for ActionTypes: SendPadding, BlockOutgoing, UpdateTimer
	Timeout time.Duration

	// Used for ActionTypes: BlockOutgoing, UpdateTimer
	Duration time.Duration

	// Used for ActionTypes: SendPadding, BlockOutgoing, UpdateTimer
	Replace bool

	// Used for ActionType: SendPadding, BlockOutgoing
	Bypass bool
}

type Padding struct {
	Replace bool
}

func (peer *Peer) EnableDaita(machines string, eventsCapacity uint, actionsCapacity uint, maxPaddingBytes float64, maxBlockingBytes float64) bool {
	peer.Lock()
	defer peer.Unlock()

	if !peer.isRunning.Load() {
		return false
	}

	if peer.daita != nil {
		peer.device.log.Errorf("Failed to activate DAITA as it is already active")
		return false
	}

	peer.device.log.Verbosef("Enabling DAITA for peer: %v", peer)

	mtu := peer.device.tun.mtu.Load()

	peer.device.log.Verbosef("MTU %v", mtu)
	var maybenot *C.MaybenotFramework
	c_machines := C.CString(machines)

	c_maxPaddingBytes := C.double(maxPaddingBytes)
	c_maxBlockingBytes := C.double(maxBlockingBytes)

	maybenot_result := C.maybenot_start(
		c_machines, c_maxPaddingBytes, c_maxBlockingBytes, &maybenot,
	)
	C.free(unsafe.Pointer(c_machines))

	if maybenot_result != 0 {
		peer.device.log.Errorf("Failed to initialize maybenot, code=%d", maybenot_result)
		return false
	}

	numMachines := C.maybenot_num_machines(maybenot)
	daita := MaybenotDaita{
		events:        make(chan Event, eventsCapacity),
		maybenot:      maybenot,
		newActionsBuf: make([]C.MaybenotAction, numMachines),
		paddingQueue:  map[uint64]*time.Timer{},
		logger:        peer.device.log,
	}

	daita.stopping.Add(1)
	go daita.handleEvents(peer)
	peer.daita = &daita

	return true
}

// Stop the MaybenotDaita instance. It must not be used after calling this.
func (daita *MaybenotDaita) Close() {
	daita.logger.Verbosef("Waiting for DAITA routines to stop")
	close(daita.events)
	for _, queuedPadding := range daita.paddingQueue {
		if queuedPadding.Stop() {
			daita.stopping.Done()
		}
	}
	daita.stopping.Wait()
	daita.logger.Verbosef("DAITA routines have stopped")
}

func (daita *MaybenotDaita) NormalRecv(peer *Peer, packetLen uint) {
	daita.event(peer, NormalRecv, packetLen, 0)
}

func (daita *MaybenotDaita) PaddingRecv(peer *Peer, packetLen uint) {
	daita.event(peer, PaddingRecv, packetLen, 0)
}

func (daita *MaybenotDaita) PaddingSent(peer *Peer, packetLen uint, machine uint64) {
	daita.event(peer, PaddingSent, packetLen, machine)
}

func (daita *MaybenotDaita) NormalSent(peer *Peer, packetLen uint) {
	daita.event(peer, NormalSent, packetLen, 0)
}

func (daita *MaybenotDaita) event(peer *Peer, eventType EventType, packetLen uint, machine uint64) {
	if daita == nil {
		return
	}

	event := Event{
		Machine:   machine,
		Peer:      peer.handshake.remoteStatic,
		EventType: eventType,
		XmitBytes: uint16(packetLen),
	}

	select {
	case daita.events <- event:
	default:
		peer.device.log.Verbosef("Dropped DAITA event %v due to full buffer", event.EventType)
	}
}

func injectPadding(action Action, peer *Peer) {
	if action.ActionType != C.MaybenotAction_SendPadding {
		return
	}

	elem := peer.device.NewOutboundElement()

	// TODO: What size of packet should be generated here? Max size?
	// constant_packet_size is still a seperate setting, but maybenot 2 does not define nor care
	// about packet size anymore.
	size := DaitaHeaderLen
	//size := action.Payload.ByteCount
	//if size < DaitaHeaderLen || size > uint16(peer.device.tun.mtu.Load()) {
	//	peer.device.log.Errorf("DAITA padding action contained invalid size %v bytes", size)
	//	return
	//}

	elem.packet = elem.buffer[MessageTransportHeaderSize : MessageTransportHeaderSize+int(size)]
	elem.packet[0] = DaitaPaddingMarker
	binary.BigEndian.PutUint16(elem.packet[DaitaOffsetTotalLength:DaitaOffsetTotalLength+2], size)

	if peer.isRunning.Load() {
		peer.StagePacket(elem)
		elem = nil
		peer.SendStagedPackets()

		peer.daita.PaddingSent(peer, uint(size), action.Machine)
	}
}

func (daita *MaybenotDaita) handleEvents(peer *Peer) {
	defer func() {
		C.maybenot_stop(daita.maybenot)
		daita.stopping.Done()
		daita.logger.Verbosef("%v - DAITA: event handler - stopped", peer)
	}()

	for {
		event, more := <-daita.events
		if !more {
			return
		}

		daita.handleEvent(event, peer)
	}
}

func (daita *MaybenotDaita) handleEvent(event Event, peer *Peer) {
	for _, cAction := range daita.maybenotEventToActions(event) {
		action := cActionToGo(cAction)

		switch action.ActionType {
		case C.MaybenotAction_Cancel:
			machine := action.Machine
			// If padding is queued for the machine, cancel it
			if queuedPadding, ok := daita.paddingQueue[machine]; ok {
				if queuedPadding.Stop() {
					daita.stopping.Done()
				}
			}
		case C.MaybenotAction_SendPadding:
			// Check if a padding packet was already queued for the machine
			// If so, try to cancel it
			timer, paddingWasQueued := daita.paddingQueue[action.Machine]
			// If no padding was queued, or the action fire before we manage to
			// cancel it, we need to increment the wait group again
			if !paddingWasQueued || !timer.Stop() {
				daita.stopping.Add(1)
			}

			daita.paddingQueue[action.Machine] =
				time.AfterFunc(action.Timeout, func() {
					defer daita.stopping.Done()
					injectPadding(action, peer)
				})
		case C.MaybenotAction_BlockOutgoing:
			// TODO: implement BlockOutgoing
			daita.logger.Errorf("ignoring action type BlockOutgoing action, unimplemented")
			continue
		case C.MaybenotAction_UpdateTimer:
			// TODO: implement UpdateTimer
			daita.logger.Errorf("ignoring action type UpdateTimer action, unimplemented")
			continue
		}
	}
}

func (daita *MaybenotDaita) maybenotEventToActions(event Event) []C.MaybenotAction {
	cEvent := C.MaybenotEvent{
		machine:    C.uintptr_t(event.Machine),
		event_type: C.uint32_t(event.EventType),
	}

	var actionsWritten C.uintptr_t

	// TODO: use unsafe.SliceData instead of the pointer dereference when the Go version gets bumped to 1.20 or later
	// TODO: fetch an error string from the FFI corresponding to the error code
	result := C.maybenot_on_events(daita.maybenot, &cEvent, 1, &daita.newActionsBuf[0], &actionsWritten)
	if result != 0 {
		daita.logger.Errorf("Failed to handle event as it was a null pointer\nEvent: %d\n", event)
		return nil
	}

	newActions := daita.newActionsBuf[:actionsWritten]
	return newActions
}

func cActionToGo(action_c C.MaybenotAction) Action {
	switch action_c.tag {
	case C.MaybenotAction_Cancel:
		body := (*C.MaybenotAction_Cancel_Body)(unsafe.Pointer(&action_c.anon0[0]))
		return Action{
			ActionType: action_c.tag,
			Machine:    uint64(body.machine),
			Timer:      body.timer,
		}

	case C.MaybenotAction_SendPadding:
		body := (*C.MaybenotAction_SendPadding_Body)(unsafe.Pointer(&action_c.anon0[0]))
		return Action{
			ActionType: action_c.tag,
			Machine:    uint64(body.machine),
			Timeout:    maybenotDurationToGoDuration(body.timeout),
			Replace:    bool(body.replace),
			Bypass:     bool(body.bypass),
		}

	case C.MaybenotAction_BlockOutgoing:
		body := (*C.MaybenotAction_BlockOutgoing_Body)(unsafe.Pointer(&action_c.anon0[0]))
		return Action{
			ActionType: action_c.tag,
			Machine:    uint64(body.machine),
			Timeout:    maybenotDurationToGoDuration(body.timeout),
			Replace:    bool(body.replace),
			Bypass:     bool(body.bypass),
			Duration:   maybenotDurationToGoDuration(body.duration),
		}

	case C.MaybenotAction_UpdateTimer:
		body := (*C.MaybenotAction_UpdateTimer_Body)(unsafe.Pointer(&action_c.anon0[0]))
		return Action{
			ActionType: action_c.tag,
			Machine:    uint64(body.machine),
			Duration:   maybenotDurationToGoDuration(body.duration),
			Replace:    bool(body.replace),
		}

	default:
		panic("Unknown C.MaybenotAction tag")
	}
}

func maybenotDurationToGoDuration(duration C.MaybenotDuration) time.Duration {
	// let's just assume this is fine...
	nanoseconds := uint64(duration.secs)*1_000_000_000 + uint64(duration.nanos)
	return time.Duration(nanoseconds)
}
